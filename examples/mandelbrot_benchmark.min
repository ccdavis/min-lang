// Mandelbrot Set Performance Benchmark
// Tests performance with high iteration count and resolution

print("=== Mandelbrot Performance Benchmark ===");
print("");

// Test 1: Standard resolution, high iterations
print("Test 1: 100x50 @ 500 iterations");
const WIDTH1: int = 100;
const HEIGHT1: int = 50;
const MAX_ITER1: int = 500;

var totalIterations: int = 0;
var row: int = 0;

for row < HEIGHT1 {
    var col: int = 0;
    for col < WIDTH1 {
        // Map to complex plane
        var cx: float = -2.5 + 3.5 * col / WIDTH1;
        var cy: float = -1.25 + 2.5 * row / HEIGHT1;

        // Mandelbrot iteration
        var x: float = 0.0;
        var y: float = 0.0;
        var iter: int = 0;

        for iter < MAX_ITER1 {
            var x2: float = x * x;
            var y2: float = y * y;

            if x2 + y2 > 4.0 {
                break;
            }

            var xtemp: float = x2 - y2 + cx;
            y = 2.0 * x * y + cy;
            x = xtemp;

            iter = iter + 1;
        }

        totalIterations = totalIterations + iter;
        col = col + 1;
    }
    row = row + 1;
}

print("Pixels calculated:", WIDTH1 * HEIGHT1);
print("Total iterations:", totalIterations);
print("Average iterations per pixel:", totalIterations / (WIDTH1 * HEIGHT1));
print("");

// Test 2: Detail zoom (more computation per pixel)
print("Test 2: Deep zoom @ 1000 iterations");
const WIDTH2: int = 60;
const HEIGHT2: int = 30;
const MAX_ITER2: int = 1000;

// Zoom into interesting region
const ZOOM_X: float = -0.5;
const ZOOM_Y: float = 0.0;
const ZOOM_SIZE: float = 0.5;

totalIterations = 0;
row = 0;

for row < HEIGHT2 {
    var col: int = 0;
    for col < WIDTH2 {
        var cx: float = ZOOM_X - ZOOM_SIZE + 2.0 * ZOOM_SIZE * col / WIDTH2;
        var cy: float = ZOOM_Y - ZOOM_SIZE + 2.0 * ZOOM_SIZE * row / HEIGHT2;

        var x: float = 0.0;
        var y: float = 0.0;
        var iter: int = 0;

        for iter < MAX_ITER2 {
            var x2: float = x * x;
            var y2: float = y * y;

            if x2 + y2 > 4.0 {
                break;
            }

            var xtemp: float = x2 - y2 + cx;
            y = 2.0 * x * y + cy;
            x = xtemp;

            iter = iter + 1;
        }

        totalIterations = totalIterations + iter;
        col = col + 1;
    }
    row = row + 1;
}

print("Pixels calculated:", WIDTH2 * HEIGHT2);
print("Total iterations:", totalIterations);
print("Average iterations per pixel:", totalIterations / (WIDTH2 * HEIGHT2));
print("");

// Test 3: Multiple frames (animation simulation)
print("Test 3: Multi-frame calculation (10 frames)");
const FRAMES: int = 10;
const FRAME_WIDTH: int = 40;
const FRAME_HEIGHT: int = 20;
const FRAME_ITERS: int = 100;

var totalPixels: int = 0;
var frame: int = 0;

for frame < FRAMES {
    // Zoom level changes per frame
    var zoomFactor: float = 1.0 - frame * 0.05;

    row = 0;
    for row < FRAME_HEIGHT {
        var col: int = 0;
        for col < FRAME_WIDTH {
            var cx: float = -2.0 * zoomFactor + 3.0 * zoomFactor * col / FRAME_WIDTH;
            var cy: float = -1.0 * zoomFactor + 2.0 * zoomFactor * row / FRAME_HEIGHT;

            var x: float = 0.0;
            var y: float = 0.0;
            var iter: int = 0;

            for iter < FRAME_ITERS {
                var x2: float = x * x;
                var y2: float = y * y;

                if x2 + y2 > 4.0 {
                    break;
                }

                var xtemp: float = x2 - y2 + cx;
                y = 2.0 * x * y + cy;
                x = xtemp;

                iter = iter + 1;
            }

            totalPixels = totalPixels + 1;
            col = col + 1;
        }
        row = row + 1;
    }
    frame = frame + 1;
}

print("Frames calculated:", FRAMES);
print("Total pixels:", totalPixels);
print("Pixels per frame:", FRAME_WIDTH * FRAME_HEIGHT);
print("");

// Test 4: Stress test with very high iterations
print("Test 4: Stress test (single point @ 10000 iterations)");
const STRESS_ITERS: int = 10000;

var cx: float = -0.7;
var cy: float = 0.0;
var x: float = 0.0;
var y: float = 0.0;
var iter: int = 0;

for iter < STRESS_ITERS {
    var x2: float = x * x;
    var y2: float = y * y;

    if x2 + y2 > 4.0 {
        break;
    }

    var xtemp: float = x2 - y2 + cx;
    y = 2.0 * x * y + cy;
    x = xtemp;

    iter = iter + 1;
}

print("Point:", cx, "+", cy, "i");
print("Escaped at iteration:", iter);
print("");

print("=== Benchmark Complete ===");
